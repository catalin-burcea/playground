## Interpreter -  A Behavioral Design Pattern

The pattern defines the grammar of a particular language in an object-oriented way and provides an interpreter to deal with this grammar.

**Examples**

* This pattern is **used in SQL parsing, symbol processing engine, human languages** etc.
* Roman numeral system interpreted to the decimal system. 

This pattern performs upon a hierarchy of expressions. **Each expression here is a terminal or non-terminal.**
The **tree structure** of Interpreter design pattern is somewhat similar to that defined by the composite design pattern with terminal expressions being leaf objects and non-terminal expressions being composites.
The tree contains the expressions to be evaluated and is usually generated by a **parser**. The parser itself is not a part of the interpreter pattern.

**Components**

* **AbstractExpression** - interprets the commands
* **TerminalExpressions** and **NonTerminalExpression**
* **InterpreterContext** - holds the data being interpreted.
* **Client** - creates or uses an already created  **abstract syntax tree**, which is nothing more than a sentence defined in the created language.

**JDK examples**

* java.util.Pattern
* java.text.Format
* java.text.Normalizer.

**Disadvantage** - When the grammar is getting more complex, it becomes harder to maintain.

## References

* https://www.baeldung.com/java-interpreter-pattern
* https://www.geeksforgeeks.org/interpreter-design-pattern/
* https://www.tutorialspoint.com/design_pattern/interpreter_pattern.htm
